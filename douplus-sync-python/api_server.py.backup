"""
Flask API服务器
提供HTTP接口供前端调用
"""
from flask import Flask, jsonify, request
from flask_cors import CORS
from celery_app import app as celery_app
from app.config import get_settings
from app.models import engine, DouyinAccount, SysUser
from app.utils.auth import generate_token, verify_password, hash_password, require_auth, JWT_EXPIRATION
from sqlalchemy.orm import sessionmaker
from loguru import logger
from datetime import datetime
import sys

# 配置日志
logger.remove()
logger.add(sys.stdout, format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}")
logger.add("logs/api.log", rotation="500 MB", retention="30 days")

settings = get_settings()
Session = sessionmaker(bind=engine)

# 创建Flask应用
app = Flask(__name__)
CORS(app)  # 允许跨域

# 同步状态存储（简单内存存储，生产环境建议用Redis）
sync_status = {}


def get_client_ip():
    """获取客户端IP"""
    if request.headers.get('X-Forwarded-For'):
        return request.headers.get('X-Forwarded-For').split(',')[0]
    elif request.headers.get('X-Real-IP'):
        return request.headers.get('X-Real-IP')
    return request.remote_addr


@app.route('/health', methods=['GET'])
def health_check():
    """健康检查"""
    return jsonify({
        'status': 'ok',
        'service': 'douplus-sync-api',
        'celery_active': celery_app.control.inspect().active() is not None
    })


# ==================== 认证相关接口 ====================

@app.route('/api/auth/login', methods=['POST'])
def login():
    """
    用户登录
    """
    data = request.get_json()
    if not data or not data.get('username') or not data.get('password'):
        return jsonify({
            'code': 400,
            'message': '用户名和密码不能为空',
            'success': False
        }), 400
    
    username = data.get('username')
    password = data.get('password')
    
    db = Session()
    try:
        # 查询用户
        user = db.query(SysUser).filter(
            SysUser.username == username,
            SysUser.deleted == 0
        ).first()
        
        if not user:
            return jsonify({
                'code': 2001,
                'message': '用户名或密码错误',
                'success': False
            }), 400
        
        # 验证状态
        if user.status != 1:
            return jsonify({
                'code': 2002,
                'message': '账号已被禁用',
                'success': False
            }), 400
        
        # 验证密码
        if not verify_password(password, user.password):
            return jsonify({
                'code': 2001,
                'message': '用户名或密码错误',
                'success': False
            }), 400
        
        # 生成Token
        token = generate_token(user.id, user.username)
        
        # 更新登录信息
        user.last_login_time = datetime.now()
        user.last_login_ip = get_client_ip()
        db.commit()
        
        logger.info(f"用户登录成功: {user.username}")
        
        return jsonify({
            'code': 200,
            'message': '登录成功',
            'data': {
                'accessToken': token,
                'tokenType': 'Bearer',
                'expiresIn': JWT_EXPIRATION,
                'user': {
                    'id': user.id,
                    'username': user.username,
                    'nickname': user.nickname,
                    'avatar': user.avatar,
                    'email': user.email,
                    'phone': user.phone,
                    'status': user.status,
                    'lastLoginTime': user.last_login_time.isoformat() if user.last_login_time else None,
                    'hasInvestPassword': bool(user.invest_password)
                }
            },
            'success': True
        })
    except Exception as e:
        logger.error(f"登录失败: {str(e)}")
        db.rollback()
        return jsonify({
            'code': 500,
            'message': f'登录失败: {str(e)}',
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/auth/info', methods=['GET'])
@require_auth
def get_user_info():
    """
    获取当前用户信息
    """
    user_id = request.user_id
    
    db = Session()
    try:
        user = db.query(SysUser).filter(
            SysUser.id == user_id,
            SysUser.deleted == 0
        ).first()
        
        if not user:
            return jsonify({
                'code': 1001,
                'message': '用户不存在',
                'success': False
            }), 404
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': {
                'id': user.id,
                'username': user.username,
                'nickname': user.nickname,
                'avatar': user.avatar,
                'email': user.email,
                'phone': user.phone,
                'status': user.status,
                'lastLoginTime': user.last_login_time.isoformat() if user.last_login_time else None,
                'hasInvestPassword': bool(user.invest_password)
            },
            'success': True
        })
    except Exception as e:
        logger.error(f"获取用户信息失败: {str(e)}")
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/auth/logout', methods=['POST'])
@require_auth
def logout():
    """
    退出登录（JWT无状态，客户端清除Token即可）
    """
    return jsonify({
        'code': 200,
        'message': '退出成功',
        'success': True
    })


@app.route('/api/auth/password', methods=['POST'])
@require_auth
def change_password():
    """
    修改密码
    """
    data = request.get_json()
    if not data or not data.get('oldPassword') or not data.get('newPassword'):
        return jsonify({
            'code': 400,
            'message': '旧密码和新密码不能为空',
            'success': False
        }), 400
    
    user_id = request.user_id
    old_password = data.get('oldPassword')
    new_password = data.get('newPassword')
    
    db = Session()
    try:
        user = db.query(SysUser).filter(SysUser.id == user_id).first()
        
        if not user:
            return jsonify({
                'code': 1001,
                'message': '用户不存在',
                'success': False
            }), 404
        
        # 验证旧密码
        if not verify_password(old_password, user.password):
            return jsonify({
                'code': 2003,
                'message': '旧密码错误',
                'success': False
            }), 400
        
        # 更新密码
        user.password = hash_password(new_password)
        user.update_time = datetime.now()
        db.commit()
        
        logger.info(f"用户{user.username}修改密码成功")
        
        return jsonify({
            'code': 200,
            'message': '密码修改成功',
            'success': True
        })
    except Exception as e:
        logger.error(f"修改密码失败: {str(e)}")
        db.rollback()
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/auth/invest-password', methods=['POST'])
@require_auth
def set_invest_password():
    """
    设置投放密码
    """
    data = request.get_json()
    if not data or not data.get('investPassword'):
        return jsonify({
            'code': 400,
            'message': '投放密码不能为空',
            'success': False
        }), 400
    
    user_id = request.user_id
    invest_password = data.get('investPassword')
    
    db = Session()
    try:
        user = db.query(SysUser).filter(SysUser.id == user_id).first()
        
        if not user:
            return jsonify({
                'code': 1001,
                'message': '用户不存在',
                'success': False
            }), 404
        
        # 更新投放密码
        user.invest_password = hash_password(invest_password)
        user.update_time = datetime.now()
        db.commit()
        
        logger.info(f"用户{user.username}设置投放密码成功")
        
        return jsonify({
            'code': 200,
            'message': '投放密码设置成功',
            'success': True
        })
    except Exception as e:
        logger.error(f"设置投放密码失败: {str(e)}")
        db.rollback()
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/auth/verify-invest-password', methods=['POST'])
@require_auth
def verify_invest_password_api():
    """
    验证投放密码
    """
    data = request.get_json()
    if not data or not data.get('investPassword'):
        return jsonify({
            'code': 400,
            'message': '投放密码不能为空',
            'success': False
        }), 400
    
    user_id = request.user_id
    invest_password = data.get('investPassword')
    
    db = Session()
    try:
        user = db.query(SysUser).filter(SysUser.id == user_id).first()
        
        if not user:
            return jsonify({
                'code': 1001,
                'message': '用户不存在',
                'success': False
            }), 404
        
        if not user.invest_password:
            return jsonify({
                'code': 2004,
                'message': '未设置投放密码',
                'success': False
            }), 400
        
        # 验证投放密码
        if not verify_password(invest_password, user.invest_password):
            return jsonify({
                'code': 2005,
                'message': '投放密码错误',
                'success': False
            }), 400
        
        return jsonify({
            'code': 200,
            'message': '验证成功',
            'data': True,
            'success': True
        })
    except Exception as e:
        logger.error(f"验证投放密码失败: {str(e)}")
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


# ==================== 账号管理相关接口 ====================

@app.route('/api/account/list', methods=['GET'])
@require_auth
def get_account_list():
    """
    获取账号列表
    """
    user_id = request.user_id
    
    db = Session()
    try:
        from sqlalchemy import text
        
        query_sql = """
            SELECT 
                id, open_id, advertiser_id, nickname, avatar, 
                fans_count, following_count, total_favorited, 
                status, daily_limit, balance, remark, 
                token_expires_at, create_time
            FROM douyin_account
            WHERE user_id = :user_id AND deleted = 0
            ORDER BY create_time DESC
        """
        
        results = db.execute(text(query_sql), {'user_id': user_id}).fetchall()
        
        # 转换为字典列表
        accounts = []
        for row in results:
            from datetime import datetime, timedelta
            
            # 判断Token是否即将过期（7天内）
            token_expiring_soon = False
            if row[12]:  # token_expires_at
                if isinstance(row[12], str):
                    expires_at = datetime.fromisoformat(row[12])
                else:
                    expires_at = row[12]
                token_expiring_soon = expires_at < datetime.now() + timedelta(days=7)
            
            account = {
                'id': row[0],
                'openId': row[1],
                'advertiserId': row[2],
                'douyinId': row[1],  # douyinId使用openId
                'nickname': row[3],
                'avatar': row[4],
                'fansCount': row[5] or 0,
                'followingCount': row[6] or 0,
                'totalFavorited': row[7] or 0,
                'status': row[8],
                'dailyLimit': float(row[9]) if row[9] else 0,
                'balance': float(row[10]) if row[10] else 0,
                'couponCount': 0,
                'remark': row[11],
                'companyName': None,
                'tokenExpiresAt': row[12].isoformat() if row[12] else None,
                'createTime': row[13].isoformat() if row[13] else None,
                'tokenExpiringSoon': token_expiring_soon
            }
            accounts.append(account)
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': accounts,
            'success': True
        })
        
    except Exception as e:
        logger.error(f"查询账号列表失败: {str(e)}")
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/account/<int:account_id>', methods=['GET'])
@require_auth
def get_account_by_id(account_id):
    """
    获取指定账号的详细信息
    """
    user_id = request.user_id
    
    db = Session()
    try:
        from sqlalchemy import text
        
        query_sql = text("""
            SELECT 
                id, open_id, advertiser_id, nickname, avatar, 
                fans_count, following_count, total_favorited, 
                status, daily_limit, balance, remark, 
                token_expires_at, create_time
            FROM douyin_account
            WHERE id = :account_id AND user_id = :user_id AND deleted = 0
        """)
        
        row = db.execute(query_sql, {
            'account_id': account_id,
            'user_id': user_id
        }).fetchone()
        
        if not row:
            return jsonify({
                'code': 404,
                'message': '账号不存在',
                'success': False
            }), 404
        
        from datetime import datetime, timedelta
        
        # 判断Token是否即将过期（7天内）
        token_expiring_soon = False
        if row[12]:  # token_expires_at
            if isinstance(row[12], str):
                expires_at = datetime.fromisoformat(row[12])
            else:
                expires_at = row[12]
            token_expiring_soon = expires_at < datetime.now() + timedelta(days=7)
        
        account = {
            'id': row[0],
            'openId': row[1],
            'advertiserId': row[2],
            'douyinId': row[1],  # douyinId使用openId
            'nickname': row[3],
            'avatar': row[4],
            'fansCount': row[5] or 0,
            'followingCount': row[6] or 0,
            'totalFavorited': row[7] or 0,
            'status': row[8],
            'dailyLimit': float(row[9]) if row[9] else 0,
            'balance': float(row[10]) if row[10] else 0,
            'couponCount': 0,
            'remark': row[11],
            'companyName': None,
            'tokenExpiresAt': row[12].isoformat() if row[12] else None,
            'createTime': row[13].isoformat() if row[13] else None,
            'tokenExpiringSoon': token_expiring_soon
        }
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': account,
            'success': True
        })
        
    except Exception as e:
        logger.error(f"查询账号失败: {str(e)}")
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


# ==================== DOU+同步相关接口 ====================

@app.route('/api/douplus/task/page', methods=['GET'])
@require_auth
def get_task_page():
    """
    分页查询投放记录（从新表结构查询，架构已完全解耦）
    
    架构说明：
    1. 订单基础信息从 douplus_order 查询（新表）
    2. 效果数据从 douplus_video_stats_agg 预聚合表查询
    3. 不使用JOIN，分步查询后组装
    """
    user_id = request.user_id
    page_num = int(request.args.get('pageNum', 1))
    page_size = int(request.args.get('pageSize', 10))
    status = request.args.get('status')
    account_id = request.args.get('accountId')
    sort_field = request.args.get('sortField', 'createTime')
    sort_order = request.args.get('sortOrder', 'desc')
    
    # 处理特殊的pageSize=-1（表示查询全部）
    if page_size == -1:
        page_size = 10000  # 设置一个足够大的数字
    
    db = Session()
    try:
        from sqlalchemy import text
        
        # 查询最新的stat_time（预聚合表可能有延迟）
        latest_time_sql = text("SELECT MAX(stat_time) FROM douplus_video_stats_agg WHERE user_id = :user_id")
        latest_time_result = db.execute(latest_time_sql, {'user_id': user_id}).fetchone()
        stat_time_to_use = latest_time_result[0] if latest_time_result and latest_time_result[0] else datetime.now()
        
        # ===== 第一步：查询订单基础信息（douplus_order表） =====
        where_conditions = ["o.user_id = :user_id", "o.deleted = 0"]
        params = {
            'user_id': user_id,
            'stat_time': stat_time_to_use,
            'limit': page_size,
            'offset': (page_num - 1) * page_size
        }
        
        if status:
            where_conditions.append("o.status = :status")
            params['status'] = status
        
        if account_id:
            where_conditions.append("o.account_id = :account_id")
            params['account_id'] = int(account_id)
        
        where_clause = " AND ".join(where_conditions)
        
        # 构建ORDER BY
        order_mapping = {
            'createTime': 'create_time',
            'budget': 'budget',
            'scheduledTime': 'order_create_time'
        }
        order_column = order_mapping.get(sort_field, 'create_time')
        order_direction = 'ASC' if sort_order.lower() == 'asc' else 'DESC'
        
        # 查询总数
        count_sql = f"SELECT COUNT(*) as total FROM douplus_order o WHERE {where_clause}"
        total_result = db.execute(text(count_sql), params).fetchone()
        total = total_result[0] if total_result else 0
        
        # 查询订单数据（只查基础字段，不含效果数据）
        data_sql = f"""
            SELECT 
                o.id, o.user_id, o.account_id, o.item_id, o.order_id,
                o.status, o.budget, o.duration, o.target_type,
                o.aweme_title, o.aweme_cover, o.aweme_nick, o.aweme_avatar,
                o.order_create_time, o.order_start_time, o.order_end_time,
                o.create_time, o.update_time
            FROM douplus_order o
            WHERE {where_clause}
            ORDER BY o.{order_column} {order_direction}
            LIMIT :limit OFFSET :offset
        """
        
        results = db.execute(text(data_sql), params).fetchall()
        
        # ===== 第二步：批量查询效果数据（从预聚合表） =====
        # 提取所有item_id
        item_ids = [row[3] for row in results if row[3]]  # row[3] = item_id
        
        # 查询效果数据（一次查询，无JOIN）
        video_stats_map = {}
        if item_ids:
            stats_sql = text("""
                SELECT 
                    item_id, 
                    total_cost, total_play, total_like, total_comment, 
                    total_share, total_follow, total_convert, total_home_visited,
                    avg_5s_rank, avg_convert_cost,
                    play_per_100_cost, like_rate, share_rate, share_per_100_play
                FROM douplus_video_stats_agg
                WHERE item_id IN :item_ids 
                  AND stat_time = :stat_time
                  AND user_id = :user_id
            """)
            
            stats_results = db.execute(stats_sql, {
                'item_ids': tuple(item_ids),
                'stat_time': stat_time_to_use,
                'user_id': user_id
            }).fetchall()
            
            # 构建映射
            for row in stats_results:
                video_stats_map[row[0]] = {
                    'actualCost': float(row[1]) if row[1] else 0,
                    'playCount': int(row[2]) if row[2] else 0,
                    'likeCount': int(row[3]) if row[3] else 0,
                    'commentCount': int(row[4]) if row[4] else 0,
                    'shareCount': int(row[5]) if row[5] else 0,
                    'followCount': int(row[6]) if row[6] else 0,
                    'dpTargetConvertCnt': int(row[7]) if row[7] else 0,
                    'dyHomeVisited': int(row[8]) if row[8] else 0,
                    'playDuration5sRank': float(row[9]) if row[9] else 0,
                    'customConvertCost': float(row[10]) if row[10] else 0,
                    'playPer100Cost': float(row[11]) if row[11] else 0,
                    'likeRate': float(row[12]) if row[12] else 0,
                    'shareRate': float(row[13]) if row[13] else 0,
                    'sharePer100Play': float(row[14]) if row[14] else 0,
                }
        
        # ===== 第三步：组装返回数据 =====
        records = []
        for row in results:
            item_id = row[3]
            
            # 获取效果数据（如果没有则使用默认值0）
            stats = video_stats_map.get(item_id, {
                'actualCost': 0, 'playCount': 0, 'likeCount': 0, 
                'commentCount': 0, 'shareCount': 0, 'followCount': 0,
                'dpTargetConvertCnt': 0, 'dyHomeVisited': 0,
                'playDuration5sRank': 0, 'customConvertCost': 0,
                'playPer100Cost': 0, 'likeRate': 0, 'shareRate': 0, 
                'sharePer100Play': 0
            })
            
            record = {
                'id': row[0],
                'userId': row[1],
                'accountId': row[2],
                'itemId': item_id,
                'orderId': row[4],
                'taskType': 1,  # 默认视频类型
                'targetType': 1 if row[8] == 'VIDEO' else 2,
                'duration': row[7],
                'budget': float(row[6]) if row[6] else 0,
                
                # 效果数据（来自预聚合表）
                **stats,
                
                # 基础字段
                'awemeNick': row[11],
                'awemeAvatar': row[12],
                'videoTitle': row[9] or '',
                'videoCover': row[10],
                'videoCoverUrl': row[10],
                'status': row[5],
                'retryCount': 0,
                'errorMsg': None,
                'scheduledTime': row[13].isoformat() if row[13] else None,
                'executedTime': row[14].isoformat() if row[14] else None,
                'completedTime': row[15].isoformat() if row[15] else None,
                'createTime': row[16].isoformat() if row[16] else None,
                
                # 这些字段需要从账号表查（暂时为空，后续优化）
                'accountNickname': None,
                'accountAvatar': None,
                
                # 扩展字段（前端可能需要）
                'expectedExposure': 0,
                'actualExposure': stats['playCount'],  # 实际曝光就是播放量
                'clickCount': 0,
                'showCnt': 0,
                'liveClickSourceCnt': 0,
                'liveGiftUv': 0,
                'liveGiftAmount': 0,
                'liveCommentCnt': 0,
                'douplusLiveFollowCount': 0,
                'liveGiftCnt': 0,
            }
            records.append(record)
        
        result = {
            'records': records,
            'total': total,
            'size': page_size,
            'current': page_num,
            'pages': (total + page_size - 1) // page_size if page_size > 0 else 0
        }
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': result,
            'success': True
        })
        
    except Exception as e:
        logger.error(f"查询订单列表失败: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()




@app.route('/api/douplus/task/stats/<int:account_id>', methods=['GET'])
@require_auth
def get_account_stats(account_id):
    """
    获取指定账号的订单统计数据（支持时间维度筛选）
    
    参数：
    - period: 时间维度 today/7d/30d/all（默认all）
    
    返回：总消耗、总播放、总点赞等统计数据
    """
    user_id = request.user_id
    period = request.args.get('period', 'all')  # 时间维度
    
    db = Session()
    try:
        from sqlalchemy import text
        from datetime import datetime, timedelta
        
        # 计算时间范围
        now = datetime.now()
        if period == 'today':
            start_time = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif period == '7d':
            start_time = now - timedelta(days=7)
        elif period == '30d':
            start_time = now - timedelta(days=30)
        else:  # all
            start_time = None
        
        # 构建查询条件
        where_conditions = [
            "account_id = :account_id",
            "user_id = :user_id"
        ]
        params = {
            'account_id': account_id,
            'user_id': user_id
        }
        
        if start_time:
            where_conditions.append("stat_time >= :start_time")
            params['start_time'] = start_time
        
        where_clause = " AND ".join(where_conditions)
        
        # 查询最新的stat_time
        latest_time_sql = text(f"""
            SELECT MAX(stat_time) 
            FROM douplus_video_stats_agg
            WHERE {where_clause}
        """)
        
        latest_time_result = db.execute(latest_time_sql, params).fetchone()
        latest_time = latest_time_result[0] if latest_time_result and latest_time_result[0] else None
        
        if not latest_time:
            stats = {
                'cost': 0,
                'playCount': 0,
                'likeCount': 0,
                'commentCount': 0,
                'shareCount': 0,
                'fansCount': 0,
                'convertCount': 0,
                'videoCount': 0,
                'orderCount': 0,
            }
        else:
            # 从预聚合表查询该账号的统计（按时间维度聚合）
            stats_sql = text(f"""
                SELECT 
                    SUM(total_cost) as total_cost,
                    SUM(total_play) as total_play,
                    SUM(total_like) as total_like,
                    SUM(total_comment) as total_comment,
                    SUM(total_share) as total_share,
                    SUM(total_follow) as total_follow,
                    SUM(total_convert) as total_convert,
                    COUNT(DISTINCT item_id) as video_count,
                    SUM(order_count) as order_count
                FROM douplus_video_stats_agg
                WHERE {where_clause}
                  AND stat_time = :stat_time
            """)
            
            params['stat_time'] = latest_time
            result = db.execute(stats_sql, params).fetchone()
            
            if result:
                stats = {
                    'cost': float(result[0]) if result[0] else 0,
                    'playCount': int(result[1]) if result[1] else 0,
                    'likeCount': int(result[2]) if result[2] else 0,
                    'commentCount': int(result[3]) if result[3] else 0,
                    'shareCount': int(result[4]) if result[4] else 0,
                    'fansCount': int(result[5]) if result[5] else 0,
                    'convertCount': int(result[6]) if result[6] else 0,
                    'videoCount': int(result[7]) if result[7] else 0,
                    'orderCount': int(result[8]) if result[8] else 0,
                }
            else:
                stats = {
                    'cost': 0,
                    'playCount': 0,
                    'likeCount': 0,
                    'commentCount': 0,
                    'shareCount': 0,
                    'fansCount': 0,
                    'convertCount': 0,
                    'videoCount': 0,
                    'orderCount': 0,
                }
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': stats,
            'success': True
        })
        
    except Exception as e:
        logger.error(f"查询账号统计失败: {str(e)}")
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/douplus/video/stats/<int:account_id>', methods=['GET'])
@require_auth
def get_video_stats_by_account(account_id):
    """
    获取指定账号下的视频维度统计列表（支持时间维度和排序）
    
    参数：
    - period: 时间维度 today/7d/30d/all（默认all）
    - sortBy: 排序字段 cost/playCount/likeCount/shareCount/convertCount（默认cost）
    - sortOrder: 排序方向 asc/desc（默认desc）
    - pageNum: 页码（默认1）
    - pageSize: 每页数量（默认20）
    
    返回：视频列表（item_id, 标题, 封面, 各项指标）
    """
    user_id = request.user_id
    period = request.args.get('period', 'all')
    sort_by = request.args.get('sortBy', 'cost')
    sort_order = request.args.get('sortOrder', 'desc')
    page_num = int(request.args.get('pageNum', 1))
    page_size = int(request.args.get('pageSize', 20))
    
    db = Session()
    try:
        from sqlalchemy import text
        from datetime import datetime, timedelta
        
        # 计算时间范围
        now = datetime.now()
        if period == 'today':
            start_time = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif period == '7d':
            start_time = now - timedelta(days=7)
        elif period == '30d':
            start_time = now - timedelta(days=30)
        else:  # all
            start_time = None
        
        # 构建查询条件
        where_conditions = [
            "v.account_id = :account_id",
            "v.user_id = :user_id"
        ]
        params = {
            'account_id': account_id,
            'user_id': user_id,
            'limit': page_size,
            'offset': (page_num - 1) * page_size
        }
        
        if start_time:
            where_conditions.append("v.stat_time >= :start_time")
            params['start_time'] = start_time
        
        where_clause = " AND ".join(where_conditions)
        
        # 查询最新的stat_time
        latest_time_sql = text(f"""
            SELECT MAX(stat_time) 
            FROM douplus_video_stats_agg
            WHERE account_id = :account_id AND user_id = :user_id
            {f"AND stat_time >= :start_time" if start_time else ""}
        """)
        
        latest_time_result = db.execute(latest_time_sql, params).fetchone()
        latest_time = latest_time_result[0] if latest_time_result and latest_time_result[0] else None
        
        if not latest_time:
            return jsonify({
                'code': 200,
                'message': 'success',
                'data': {
                    'records': [],
                    'total': 0,
                    'pageNum': page_num,
                    'pageSize': page_size
                },
                'success': True
            })
        
        # 排序字段映射
        sort_mapping = {
            'cost': 'v.total_cost',
            'playCount': 'v.total_play',
            'likeCount': 'v.total_like',
            'commentCount': 'v.total_comment',
            'shareCount': 'v.total_share',
            'convertCount': 'v.total_convert',
            'playPer100Cost': 'v.play_per_100_cost'
        }
        sort_column = sort_mapping.get(sort_by, 'v.total_cost')
        sort_dir = 'ASC' if sort_order.lower() == 'asc' else 'DESC'
        
        # 查询总数
        count_sql = text(f"""
            SELECT COUNT(DISTINCT v.item_id)
            FROM douplus_video_stats_agg v
            WHERE {where_clause}
              AND v.stat_time = :stat_time
        """)
        params['stat_time'] = latest_time
        total_result = db.execute(count_sql, params).fetchone()
        total = total_result[0] if total_result else 0
        
        # 查询视频列表（关联订单表获取视频信息）
        video_sql = text(f"""
            SELECT 
                v.item_id,
                MAX(o.aweme_title) as title,
                MAX(o.aweme_cover) as cover,
                v.order_count,
                v.total_budget,
                v.total_cost,
                v.total_play,
                v.total_like,
                v.total_comment,
                v.total_share,
                v.total_follow,
                v.total_convert,
                v.total_home_visited,
                v.avg_5s_rank,
                v.avg_convert_cost,
                v.play_per_100_cost,
                v.like_rate,
                v.share_rate,
                v.share_per_100_play
            FROM douplus_video_stats_agg v
            LEFT JOIN douplus_order o ON v.item_id = o.item_id AND o.deleted = 0
            WHERE {where_clause}
              AND v.stat_time = :stat_time
            GROUP BY v.item_id, v.order_count, v.total_budget, v.total_cost,
                     v.total_play, v.total_like, v.total_comment, v.total_share,
                     v.total_follow, v.total_convert, v.total_home_visited,
                     v.avg_5s_rank, v.avg_convert_cost, v.play_per_100_cost,
                     v.like_rate, v.share_rate, v.share_per_100_play
            ORDER BY {sort_column} {sort_dir}
            LIMIT :limit OFFSET :offset
        """)
        
        results = db.execute(video_sql, params).fetchall()
        
        # 组装数据
        records = []
        for row in results:
            record = {
                'itemId': row[0],
                'title': row[1] or '未知视频',
                'cover': row[2] or '',
                'orderCount': row[3] or 0,
                'totalBudget': float(row[4]) if row[4] else 0,
                'totalCost': float(row[5]) if row[5] else 0,
                'totalPlay': int(row[6]) if row[6] else 0,
                'totalLike': int(row[7]) if row[7] else 0,
                'totalComment': int(row[8]) if row[8] else 0,
                'totalShare': int(row[9]) if row[9] else 0,
                'totalFollow': int(row[10]) if row[10] else 0,
                'totalConvert': int(row[11]) if row[11] else 0,
                'totalHomeVisited': int(row[12]) if row[12] else 0,
                'avg5sRank': float(row[13]) if row[13] else 0,
                'avgConvertCost': float(row[14]) if row[14] else 0,
                'playPer100Cost': float(row[15]) if row[15] else 0,
                'likeRate': float(row[16]) if row[16] else 0,
                'shareRate': float(row[17]) if row[17] else 0,
                'sharePer100Play': float(row[18]) if row[18] else 0,
            }
            records.append(record)
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': {
                'records': records,
                'total': total,
                'pageNum': page_num,
                'pageSize': page_size,
                'pages': (total + page_size - 1) // page_size if page_size > 0 else 0
            },
            'success': True
        })
        
    except Exception as e:
        logger.error(f"查询视频统计失败: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/douplus/video/stats/all', methods=['GET'])
@require_auth
def get_all_video_stats():
    """
    获取用户所有账号的视频维度统计列表（支持时间维度和排序）
    
    参数：
    - period: 时间维度 today/7d/30d/all（默认all）
    - sortBy: 排序字段 cost/playCount/likeCount/shareCount/convertCount（默认cost）
    - sortOrder: 排序方向 asc/desc（默认desc）
    - pageNum: 页码（默认1）
    - pageSize: 每页数量（默认20）
    
    返回：所有账号的视频列表（item_id, 标题, 封面, 各项指标）
    """
    user_id = request.user_id
    period = request.args.get('period', 'all')
    sort_by = request.args.get('sortBy', 'cost')
    sort_order = request.args.get('sortOrder', 'desc')
    page_num = int(request.args.get('pageNum', 1))
    page_size = int(request.args.get('pageSize', 20))
    
    db = Session()
    try:
        from sqlalchemy import text
        from datetime import datetime, timedelta
        
        # 计算时间范围
        now = datetime.now()
        if period == 'today':
            start_time = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif period == '7d':
            start_time = now - timedelta(days=7)
        elif period == '30d':
            start_time = now - timedelta(days=30)
        else:  # all
            start_time = None
        
        # 构建查询条件
        where_conditions = [
            "v.user_id = :user_id"
        ]
        params = {
            'user_id': user_id,
            'limit': page_size,
            'offset': (page_num - 1) * page_size
        }
        
        if start_time:
            where_conditions.append("v.stat_time >= :start_time")
            params['start_time'] = start_time
        
        where_clause = " AND ".join(where_conditions)
        
        # 查询最新的stat_time
        latest_time_sql = text(f"""
            SELECT MAX(stat_time) 
            FROM douplus_video_stats_agg
            WHERE user_id = :user_id
            {f"AND stat_time >= :start_time" if start_time else ""}
        """)
        
        latest_time_result = db.execute(latest_time_sql, params).fetchone()
        latest_time = latest_time_result[0] if latest_time_result and latest_time_result[0] else None
        
        if not latest_time:
            return jsonify({
                'code': 200,
                'message': 'success',
                'data': {
                    'records': [],
                    'total': 0,
                    'pageNum': page_num,
                    'pageSize': page_size
                },
                'success': True
            })
        
        # 排序字段映射
        sort_mapping = {
            'cost': 'v.total_cost',
            'playCount': 'v.total_play',
            'likeCount': 'v.total_like',
            'commentCount': 'v.total_comment',
            'shareCount': 'v.total_share',
            'convertCount': 'v.total_convert',
            'playPer100Cost': 'v.play_per_100_cost'
        }
        sort_column = sort_mapping.get(sort_by, 'v.total_cost')
        sort_dir = 'ASC' if sort_order.lower() == 'asc' else 'DESC'
        
        # 查询总数
        count_sql = text(f"""
            SELECT COUNT(DISTINCT v.item_id)
            FROM douplus_video_stats_agg v
            WHERE {where_clause}
              AND v.stat_time = :stat_time
        """)
        params['stat_time'] = latest_time
        total_result = db.execute(count_sql, params).fetchone()
        total = total_result[0] if total_result else 0
        
        # 查询视频列表（关联订单表获取视频信息）
        video_sql = text(f"""
            SELECT 
                v.item_id,
                MAX(o.aweme_title) as title,
                MAX(o.aweme_cover) as cover,
                v.order_count,
                v.total_budget,
                v.total_cost,
                v.total_play,
                v.total_like,
                v.total_comment,
                v.total_share,
                v.total_follow,
                v.total_convert,
                v.total_home_visited,
                v.avg_5s_rank,
                v.avg_convert_cost,
                v.play_per_100_cost,
                v.like_rate,
                v.share_rate,
                v.share_per_100_play
            FROM douplus_video_stats_agg v
            LEFT JOIN douplus_order o ON v.item_id = o.item_id AND o.deleted = 0
            WHERE {where_clause}
              AND v.stat_time = :stat_time
            GROUP BY v.item_id, v.order_count, v.total_budget, v.total_cost,
                     v.total_play, v.total_like, v.total_comment, v.total_share,
                     v.total_follow, v.total_convert, v.total_home_visited,
                     v.avg_5s_rank, v.avg_convert_cost, v.play_per_100_cost,
                     v.like_rate, v.share_rate, v.share_per_100_play
            ORDER BY {sort_column} {sort_dir}
            LIMIT :limit OFFSET :offset
        """)
        
        results = db.execute(video_sql, params).fetchall()
        
        # 组装数据
        records = []
        for row in results:
            record = {
                'itemId': row[0],
                'title': row[1] or '未知视频',
                'cover': row[2] or '',
                'orderCount': row[3] or 0,
                'totalBudget': float(row[4]) if row[4] else 0,
                'totalCost': float(row[5]) if row[5] else 0,
                'totalPlay': int(row[6]) if row[6] else 0,
                'totalLike': int(row[7]) if row[7] else 0,
                'totalComment': int(row[8]) if row[8] else 0,
                'totalShare': int(row[9]) if row[9] else 0,
                'totalFollow': int(row[10]) if row[10] else 0,
                'totalConvert': int(row[11]) if row[11] else 0,
                'totalHomeVisited': int(row[12]) if row[12] else 0,
                'avg5sRank': float(row[13]) if row[13] else 0,
                'avgConvertCost': float(row[14]) if row[14] else 0,
                'playPer100Cost': float(row[15]) if row[15] else 0,
                'likeRate': float(row[16]) if row[16] else 0,
                'shareRate': float(row[17]) if row[17] else 0,
                'sharePer100Play': float(row[18]) if row[18] else 0,
            }
            records.append(record)
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': {
                'records': records,
                'total': total,
                'pageNum': page_num,
                'pageSize': page_size,
                'pages': (total + page_size - 1) // page_size if page_size > 0 else 0
            },
            'success': True
        })
        
    except Exception as e:
        logger.error(f"查询视频统计失败: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/douplus/task/stats', methods=['GET'])
@require_auth
def get_all_accounts_stats():
    """
    获取用户所有账号的汇总统计数据（支持时间维度筛选）
    
    参数：
    - period: 时间维度 today/7d/30d/all（默认all）
    
    返回：总消耗、总播放、总点赞等统计数据（所有账号加总）
    """
    user_id = request.user_id
    period = request.args.get('period', 'all')
    
    db = Session()
    try:
        from sqlalchemy import text
        from datetime import datetime, timedelta
        
        # 计算时间范围
        now = datetime.now()
        if period == 'today':
            start_time = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif period == '7d':
            start_time = now - timedelta(days=7)
        elif period == '30d':
            start_time = now - timedelta(days=30)
        else:  # all
            start_time = None
        
        # 查询最新的stat_time
        params = {'user_id': user_id}
        time_filter = ""
        if start_time:
            time_filter = "AND stat_time >= :start_time"
            params['start_time'] = start_time
        
        latest_time_sql = text(f"""
            SELECT MAX(stat_time) 
            FROM douplus_video_stats_agg
            WHERE user_id = :user_id
            {time_filter}
        """)
        
        latest_time_result = db.execute(latest_time_sql, params).fetchone()
        
        latest_time = latest_time_result[0] if latest_time_result and latest_time_result[0] else None
        
        if not latest_time:
            # 没有数据，返回0
            stats = {
                'cost': 0,
                'playCount': 0,
                'likeCount': 0,
                'commentCount': 0,
                'shareCount': 0,
                'fansCount': 0,
                'convertCount': 0,
                'videoCount': 0,
                'orderCount': 0,
            }
        else:
            # 从预聚合表查询该用户所有账号的统计（汇总）
            stats_sql = text("""
                SELECT 
                    SUM(total_cost) as total_cost,
                    SUM(total_play) as total_play,
                    SUM(total_like) as total_like,
                    SUM(total_comment) as total_comment,
                    SUM(total_share) as total_share,
                    SUM(total_follow) as total_follow,
                    SUM(total_convert) as total_convert,
                    COUNT(DISTINCT item_id) as video_count,
                    SUM(order_count) as order_count
                FROM douplus_video_stats_agg
                WHERE user_id = :user_id
                  AND stat_time = :stat_time
            """)
            
            result = db.execute(stats_sql, {
                'user_id': user_id,
                'stat_time': latest_time
            }).fetchone()
            
            if result:
                stats = {
                    'cost': float(result[0]) if result[0] else 0,
                    'playCount': int(result[1]) if result[1] else 0,
                    'likeCount': int(result[2]) if result[2] else 0,
                    'commentCount': int(result[3]) if result[3] else 0,
                    'shareCount': int(result[4]) if result[4] else 0,
                    'fansCount': int(result[5]) if result[5] else 0,  # total_follow作为粉丝量
                    'convertCount': int(result[6]) if result[6] else 0,
                    'videoCount': int(result[7]) if result[7] else 0,
                    'orderCount': int(result[8]) if result[8] else 0,
                }
            else:
                stats = {
                    'cost': 0,
                    'playCount': 0,
                    'likeCount': 0,
                    'commentCount': 0,
                    'shareCount': 0,
                    'fansCount': 0,
                    'convertCount': 0,
                    'videoCount': 0,
                    'orderCount': 0,
                }
        
        return jsonify({
            'code': 200,
            'message': 'success',
            'data': stats,
            'success': True
        })
        
    except Exception as e:
        logger.error(f"查询用户统计失败: {str(e)}")
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        }), 500
    finally:
        db.close()


@app.route('/api/douplus/task/sync-all', methods=['POST'])
@require_auth
def sync_all_orders():
    """
    同步所有账号的DOU+历史订单
    兼容Java接口格式
    """
    # 从认证信息获取用户ID，如果是无认证调用则尝试从请求体获取
    user_id = request.user_id
    
    logger.info(f"收到全量同步请求，用户ID: {user_id}")
    
    # 检查是否正在同步
    if user_id in sync_status and sync_status[user_id].get('status') == 'syncing':
        return jsonify({
            'code': 200,
            'message': '正在同步中，请稍候...',
            'data': sync_status[user_id],
            'success': True
        })
    
    # 初始化同步状态
    sync_status[user_id] = {
        'status': 'syncing',
        'count': 0,
        'message': '正在初始化同步...'
    }
    
    # 获取该用户的所有账号
    db = Session()
    try:
        accounts = db.query(DouyinAccount).filter(
            DouyinAccount.user_id == user_id,
            DouyinAccount.status == 1,
            DouyinAccount.deleted == 0
        ).all()
        
        if not accounts:
            sync_status[user_id] = {
                'status': 'error',
                'count': 0,
                'message': '没有可用的抖音账号'
            }
            return jsonify({
                'code': 400,
                'message': '没有可用的抖音账号',
                'data': sync_status[user_id],
                'success': False
            })
        
        # 异步触发每个账号的全量同步任务
        for account in accounts:
            from celery_app import app as celery_app
            celery_app.send_task(
                'app.tasks.order_sync.sync_single_account',
                args=[account.id, 'full']
            )
            logger.info(f"已提交账号{account.id}的全量同步任务到Celery队列")
        
        sync_status[user_id] = {
            'status': 'completed',
            'count': len(accounts),
            'message': f'已提交{len(accounts)}个账号的同步任务到后台队列，请稍后查看订单数据'
        }
        
        return jsonify({
            'code': 200,
            'message': '同步任务已提交',
            'data': sync_status[user_id],
            'success': True
        })
        
    except Exception as e:
        logger.error(f"同步失败: {str(e)}")
        sync_status[user_id] = {
            'status': 'error',
            'count': 0,
            'message': f'同步失败: {str(e)}'
        }
        return jsonify({
            'code': 500,
            'message': str(e),
            'data': sync_status[user_id],
            'success': False
        })
    finally:
        db.close()


@app.route('/api/douplus/task/sync-status', methods=['GET'])
@require_auth
def get_sync_status():
    """
    查询同步状态
    兼容Java接口格式
    """
    user_id = request.user_id
    
    status = sync_status.get(user_id, {
        'status': 'idle',
        'count': 0,
        'message': '无同步任务'
    })
    
    return jsonify({
        'code': 200,
        'message': 'success',
        'data': status,
        'success': True
    })


@app.route('/api/douplus/task/sync/<int:account_id>', methods=['POST'])
def sync_single_account_api(account_id):
    """
    同步单个账号的DOU+历史订单
    """
    logger.info(f"收到单账号同步请求，账号ID: {account_id}")
    
    try:
        from celery_app import app as celery_app
        task = celery_app.send_task(
            'app.tasks.order_sync.sync_single_account',
            args=[account_id, 'full']
        )
        
        return jsonify({
            'code': 200,
            'message': '同步任务已提交',
            'data': {
                'task_id': task.id,
                'status': 'syncing',
                'message': '同步任务已提交到后台队列'
            },
            'success': True
        })
    except Exception as e:
        logger.error(f"同步失败: {str(e)}")
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        })


@app.route('/api/stats/tasks', methods=['GET'])
def get_task_stats():
    """
    获取Celery任务统计信息
    """
    try:
        inspector = celery_app.control.inspect()
        
        active = inspector.active()
        scheduled = inspector.scheduled()
        reserved = inspector.reserved()
        
        return jsonify({
            'code': 200,
            'data': {
                'active_tasks': active,
                'scheduled_tasks': scheduled,
                'reserved_tasks': reserved
            },
            'success': True
        })
    except Exception as e:
        return jsonify({
            'code': 500,
            'message': str(e),
            'success': False
        })


if __name__ == '__main__':
    # 生产环境建议使用gunicorn: gunicorn -w 4 -b 0.0.0.0:5000 api_server:app
    app.run(host='0.0.0.0', port=5000, debug=False)
